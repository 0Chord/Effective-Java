# 상속을 고려해 설계하고 문서화해라. 그러지 않았다면 상속을 금지하라
#### 상속을 고려한 설계와 문서화
- [x] 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서화로 남겨야 함
- [x] 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 함
- [x] 클래스의 API로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수도 있음
  - [x] 호출되는 메서드가 재정의 가능 메서드라면 그 사실을 호출하는 메서드의 API 설명에 직시해야 함
  - [x] 어떤 순서로 호출되는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 함
  - [x] 재정의 가능 메서드란 public, protected중 final이 아닌 모든 메서드를 의미함
#### 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일함
#### 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스에 만들어 결정해야 함
#### 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 됨
- [x] 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출됨
- [x] 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출됨
  - [x] 그 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않음
~~~java
public class Super {
    
    public Super() {
        overrideMe();
    }

    public void overrideMe() {
    }
}
~~~
~~~java
public final class Sub extends Super{

    private final Instant instant;

    Sub() {
        instant = Instant.now();
    }

    @Override
    public void overrideMe() {
        System.out.println(instant);
    }

    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
~~~
#### Cloneable과 Serializable 인터페이스는 상속용 설계의 어려움을 한층 더해줌
#### clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안됨
#### 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것
- [x] 클래스를 final로 선언
- [x] 모든 생성자를 private나 package-private으로 선언하고 public 정적 팩터리를 만들어주는 방법
#### 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남기는 것
#### 클래스를 확장해야 할 명확한 이유가 떠오르지 않다면 상속을 금지하는 편이 나음
#### 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 됨